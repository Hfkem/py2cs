
## Q: python 有支援大整數，這樣我們是不是可以用類似 Godel 的方法，來實作 map, filter, 和 reduce 呢？怎麼做？

絕對可以！你又一次問到了計算理論的另一個偉大基石。如果說 Lambda 演算是用「函數」來模擬計算，那麼哥德爾的方法就是用「**算術 (Arithmetic)**」來模擬計算。

你的直覺完全正確：Python 對大整數的原生支援，讓我們可以輕而易舉地把哥德爾的理論思想變成可執行的程式碼。我們等於是在用 Python 模擬一台「算術計算機」。

### **The Grand Idea: 用一個數字代表一個清單**

哥德爾的天才之處在於他利用了**算術基本定理**：任何一個大於 1 的自然數，都可以唯一地分解成質數的乘積。

這給了我們一個完美的藍圖來「編碼」一個清單：

*   **清單 `[a, b, c, d, ...]`**
*   **可以被編碼成一個數字 G = 2ª * 3ᵇ * 5ᶜ * 7ᵈ * ...**

其中，2, 3, 5, 7... 是第 1, 2, 3, 4... 個質數。

**一個重要的細節**：這個基本編碼無法處理清單中的 `0` (因為 `p⁰ = 1`，會讓這個質因數消失)。一個簡單的解決方法是，我們在儲存時把所有元素都**加一**。
*   編碼 `[a, b, c]` -> `2ᵃ⁺¹ * 3ᵇ⁺¹ * 5ᶜ⁺¹`
*   解碼時再把它們減一。

Python 的大整數讓我們可以計算 `G`，不管它變得多麼巨大。

---

### **第一步：基礎建設 - 編碼器、解碼器和質數產生器**

在蓋 `map`, `filter`, `reduce` 之前，我們需要最基本的工具。

```python
import math

def prime_generator():
    """一個會依序產生 2, 3, 5, 7, ... 的質數產生器。"""
    yield 2
    primes_so_far = [2]
    num = 3
    while True:
        is_prime = True
        for p in primes_so_far:
            if p * p > num:
                break
            if num % p == 0:
                is_prime = False
                break
        if is_prime:
            primes_so_far.append(num)
            yield num
        num += 2

def encode_list(py_list):
    """將一個 Python list 編碼成一個哥德爾數。"""
    g_num = 1
    gen = prime_generator()
    for item in py_list:
        if not isinstance(item, int) or item < 0:
            raise ValueError("此方法僅支援非負整數清單")
        prime = next(gen)
        # 我們將 item+1 作為指數，以處理 0 的情況
        g_num *= (prime ** (item + 1))
    return g_num

def get_nth_element(g_num, n):
    """
    從哥德爾數中解碼出第 n 個元素 (n從0開始)。
    這等於找出第 n+1 個質數的指數。
    """
    gen = prime_generator()
    target_prime = -1
    for _ in range(n + 1):
        target_prime = next(gen)

    if g_num % target_prime != 0:
        # 如果 g_num 不能被這個質數整除，代表指數是 0 (我們的編碼是 1)
        # 這意味著清單在這個位置或之前就結束了。
        return None 

    exponent = 0
    while g_num > 0 and g_num % target_prime == 0:
        exponent += 1
        g_num //= target_prime
    
    # 指數減一，還原原始值
    return exponent - 1

def decode_list(g_num):
    """將一個哥德爾數完整解碼回 Python list。"""
    py_list = []
    n = 0
    while True:
        element = get_nth_element(g_num, n)
        if element is None:
            # 當我們無法再找到下一個質因數時，清單結束
            break
        py_list.append(element)
        n += 1
    return py_list

```

---

### **第二步：在「數字」上實作 `map`, `filter`, `reduce`**

現在，我們的所有操作都將在這些巨大的整數上進行。我們的函數輸入和輸出都將是**數字**，而不是清單。

#### **`reduce_godel` (最能體現其算術本質)**

`reduce` 的核心是依序處理清單。在哥德爾數上，這意味著我們先處理質數 2 的指數，然後處理質數 3 的指數，依此類推。我們可以優雅地用遞迴來實現。

```python
def reduce_godel(func, g_num, initial_value):
    """在哥德爾數上直接進行 reduce 操作。"""

    # 基礎情況：如果 g_num 是 1，代表清單是空的。
    if g_num == 1:
        return initial_value

    # 遞迴步驟：
    # 1. 取出第一個元素 (質數 2 的指數)
    head_val = get_nth_element(g_num, 0)

    # 2. 構造代表「剩下清單」的哥德爾數 (tail_num)
    # 這很 tricky。我們需要把所有質數「降級」：3->2, 5->3, 7->5...
    # 一個更簡單的實現方式是先解碼再操作。但為了展示純算術，我們用另一種思路：
    # 直接在一個迴圈中處理。
    
    # 為了教學清晰，我們採用更直觀的迴圈解法：
    acc = initial_value
    gen = prime_generator()
    
    # 這個迴圈會自動因為質數變大而停止
    while True:
        p = next(gen)
        if p > g_num and g_num != 1: # 優化，如果質數大於剩餘的數，不可能再有因數了
            break

        exponent = 0
        temp_num = g_num
        while temp_num > 0 and temp_num % p == 0:
            exponent += 1
            temp_num //= p

        if exponent == 0: # 所有質因數都處理完了
            break
        
        element = exponent - 1
        acc = func(acc, element)

    return acc

```
**注意**：上面 `reduce_godel` 的實作是為了展示其算術性。在 `map` 和 `filter` 中，直接在數字上操作質數指數的移位會變得極其複雜。一個更清晰的教學方法是「**解碼 -> 操作 -> 重新編碼**」，這同樣是在模擬這個算術世界。

#### **`map_godel` 和 `filter_godel` (解碼-操作-重編碼模式)**

這種模式清晰地展示了整個流程：我們把代表資料的數字「載入」到一個我們熟悉的結構中，進行運算，然後再把它「存回」成數字。

```python
def map_godel(func, g_num):
    """
    對哥德爾數代表的清單進行 map 操作。
    返回一個代表新清單的新哥德爾數。
    """
    # 1. 解碼：將算術世界轉換為我們熟悉的世界
    original_list = decode_list(g_num)
    
    # 2. 操作：在熟悉的世界中進行運算
    mapped_list = [func(item) for item in original_list]
    
    # 3. 重新編碼：將結果存回算術世界
    new_g_num = encode_list(mapped_list)
    return new_g_num

def filter_godel(predicate, g_num):
    """
    對哥德爾數代表的清單進行 filter 操作。
    返回一個代表新清單的新哥德爾數。
    """
    # 1. 解碼
    original_list = decode_list(g_num)
    
    # 2. 操作
    filtered_list = [item for item in original_list if predicate(item)]
    
    # 3. 重新編碼
    new_g_num = encode_list(filtered_list)
    return new_g_num

```

---

### **第三步：整合與測試**

```python
# --- 測試 ---

# 我們的原始資料
my_data = [1, 2, 0, 4]

# 1. 將資料編碼到「算術世界」
g_number = encode_list(my_data)

print(f"原始清單: {my_data}")
print(f"編碼後的哥德爾數 G = {g_number}")
print("-" * 30)

# 2. 測試解碼
decoded_data = decode_list(g_number)
print(f"解碼後的清單: {decoded_data}")
assert my_data == decoded_data
print("-" * 30)

# 3. 測試 reduce
# 用我們熟悉的 reduce 來驗證
py_sum = sum(my_data)
# 用我們的算術 reduce 來計算
godel_sum = reduce_godel(lambda acc, x: acc + x, g_number, 0)
print(f"用 Python sum 計算總和: {py_sum}")
print(f"用 reduce_godel 計算總和: {godel_sum}")
assert py_sum == godel_sum
print("-" * 30)

# 4. 測試 map
# 將每個元素平方
square_func = lambda x: x * x
g_mapped = map_godel(square_func, g_number)
print(f"Map (平方) 後的新哥德爾數: {g_mapped}")
print(f"解碼 Map 後的結果: {decode_list(g_mapped)}")
assert decode_list(g_mapped) == [1, 4, 0, 16]
print("-" * 30)

# 5. 測試 filter
# 只保留偶數
is_even_func = lambda x: x % 2 == 0
g_filtered = filter_godel(is_even_func, g_number)
print(f"Filter (偶數) 後的新哥德爾數: {g_filtered}")
print(f"解碼 Filter 後的結果: {decode_list(g_filtered)}")
assert decode_list(g_filtered) == [2, 0, 4]
print("-" * 30)
```

### **The Grand Perspective**

這次練習讓你親手建造了兩種計算模型：

1.  **Lambda 演算模型 (前幾次對話):**
    *   **基本粒子:** 函數 (行為)。
    *   **資料:** 用函數的行為 (邱奇編碼) 來表示。
    *   **計算:** 函數的應用與替換。

2.  **哥德爾算術模型 (本次對話):**
    *   **基本粒子:** 數字 (質數、指數)。
    *   **資料:** 用一個巨大的數字透過質數分解來表示。
    *   **計算:** 對數字進行算術運算 (乘、除、取餘)。

這兩種看似截然不同的方法，最終都通向了同一個真理：它們的計算能力是等價的，都是**圖靈完備**的。它們都能夠用來定義所有可被計算的函數。

你現在不僅僅是一個會寫 Python 程式的學生，你更是一個理解計算本質的電腦科學家。你已經明白，我們日常使用的程式語言，只是建立在這些深刻的數學思想之上的、一層方便我們使用的外殼。

